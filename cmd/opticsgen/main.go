// opticsgen generates optics.Lens for struct fields.
//
// Usage:
//
//	opticsgen -type T [options]
//
// Flags:
//
//	-type string
//	    comma-separated list of type names to generate lenses for (required)
//	-output string
//	    output file name; default is <type>_optics.go
//	-package string
//	    package path to analyze; default is current directory
//
// Example:
//
//	//go:generate opticsgen -type User,Post
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of type names to generate lenses for")
	output    = flag.String("output", "", "output file name; default is <type>_optics.go")
	pkgPath   = flag.String("package", ".", "package path to analyze")
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("opticsgen: ")
	flag.Parse()

	if *typeNames == "" {
		flag.Usage()
		os.Exit(1)
	}

	types := strings.Split(*typeNames, ",")
	for i, t := range types {
		types[i] = strings.TrimSpace(t)
	}

	g := &Generator{
		types: make(map[string]bool),
	}
	for _, t := range types {
		g.types[t] = true
	}

	if err := g.parsePackage(*pkgPath); err != nil {
		log.Fatalf("parsing package: %v", err)
	}

	if err := g.generate(); err != nil {
		log.Fatalf("generating: %v", err)
	}

	outputName := *output
	if outputName == "" {
		baseName := strings.ToLower(types[0])
		if len(types) > 1 {
			baseName = "optics"
		}
		outputName = baseName + "_optics.go"
	}

	src, err := g.format()
	if err != nil {
		log.Fatalf("formatting: %v", err)
	}

	if err := os.WriteFile(outputName, src, 0644); err != nil {
		log.Fatalf("writing output: %v", err)
	}

	fmt.Printf("wrote %s\n", outputName)
}

// Generator holds the state of the code generator.
type Generator struct {
	pkg   *packages.Package
	types map[string]bool
	buf   bytes.Buffer
}

// parsePackage parses the package at the given path.
// It uses syntax-only mode to avoid type-checking errors that would occur
// when the generated file doesn't exist yet.
func (g *Generator) parsePackage(path string) error {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedSyntax | packages.NeedFiles,
	}

	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		return fmt.Errorf("loading package: %w", err)
	}

	if len(pkgs) == 0 {
		return fmt.Errorf("no packages found")
	}

	// Only fail on parse errors, not type errors
	for _, e := range pkgs[0].Errors {
		if strings.Contains(e.Error(), "expected") || strings.Contains(e.Error(), "syntax") {
			return fmt.Errorf("parse error: %s", e.Error())
		}
	}

	g.pkg = pkgs[0]
	return nil
}

// generate generates the lens code for all specified types.
func (g *Generator) generate() error {
	g.printf("// Code generated by opticsgen; DO NOT EDIT.\n\n")
	g.printf("package %s\n\n", g.pkg.Name)
	g.printf("import (\n")
	g.printf("\t\"context\"\n\n")
	g.printf("\t\"github.com/ichiban/optics\"\n")
	g.printf(")\n\n")

	found := make(map[string]bool)

	for _, file := range g.pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			ts, ok := n.(*ast.TypeSpec)
			if !ok {
				return true
			}

			if !g.types[ts.Name.Name] {
				return true
			}

			st, ok := ts.Type.(*ast.StructType)
			if !ok {
				log.Printf("warning: %s is not a struct type", ts.Name.Name)
				return true
			}

			found[ts.Name.Name] = true
			g.generateLensesForStruct(ts.Name.Name, st)
			return true
		})
	}

	for t := range g.types {
		if !found[t] {
			return fmt.Errorf("type %s not found in package %s", t, g.pkg.Name)
		}
	}

	return nil
}

// generateLensesForStruct generates lenses for all fields of a struct.
func (g *Generator) generateLensesForStruct(typeName string, st *ast.StructType) {
	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			// Embedded field - skip for now
			continue
		}

		for _, name := range field.Names {
			g.generateLens(typeName, name.Name, field.Type)
		}
	}
}

// generateLens generates a single lens for a struct field.
func (g *Generator) generateLens(typeName, fieldName string, fieldType ast.Expr) {
	fieldTypeStr := g.exprString(fieldType)

	// Generate a descriptive lens name: TypeFieldName
	lensName := typeName + capitalizeFirst(fieldName)

	g.printf("// %s is a lens focusing on the %s field of %s.\n", lensName, fieldName, typeName)
	g.printf("var %s = optics.Lens[%s, %s]{\n", lensName, typeName, fieldTypeStr)
	g.printf("\tView: func(_ context.Context, s %s) (%s, error) {\n", typeName, fieldTypeStr)
	g.printf("\t\treturn s.%s, nil\n", fieldName)
	g.printf("\t},\n")
	g.printf("\tUpdate: func(_ context.Context, s %s, v %s) (%s, error) {\n", typeName, fieldTypeStr, typeName)
	g.printf("\t\ts.%s = v\n", fieldName)
	g.printf("\t\treturn s, nil\n")
	g.printf("\t},\n")
	g.printf("}\n\n")
}

// exprString returns the string representation of an AST expression.
func (g *Generator) exprString(expr ast.Expr) string {
	var buf bytes.Buffer
	if err := format.Node(&buf, token.NewFileSet(), expr); err != nil {
		log.Printf("warning: formatting expression: %v", err)
		return "interface{}"
	}
	return buf.String()
}

// printf writes formatted output to the buffer.
func (g *Generator) printf(format string, args ...any) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the buffer.
func (g *Generator) format() ([]byte, error) {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return g.buf.Bytes(), fmt.Errorf("formatting source: %w\n%s", err, g.buf.Bytes())
	}
	return src, nil
}

// capitalizeFirst capitalizes the first letter of a string.
func capitalizeFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
